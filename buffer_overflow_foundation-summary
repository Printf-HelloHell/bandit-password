https://drive.google.com/file/d/1KsqEACuvRmRqlF6tR0vjcHNOoSyGbYV-/view


<8086 memory architecture>

- 메모리 영역에 주소 할당할 수 있는 범위
: cpu가 한꺼번에 처리할 수 있는 데이터가 몇 비트 단위인지에 따라... nbit => 0 ~ 2^n-1

- 시스템은 커널에서 기본적인 명령어 집합을 찾음 => 커널 영역의 위치는 정해져 있음 ( 오늘날의 운영체제들은 더 큰 영역을 사용하지만 기본적으로는 64kbyte)
  
- 커널을 메모리에 적재시킨 후 가용 메모리 영역에 여러 개의 segment 저장 가능
  segment의 위치는 실행 시점에 정해짐

- segment 구조 : code segment + data segment + stack segment

   # code segment : 시스템이 알아들을 수 있는 명령어(instruction)들이 들어 있음
   instruction이 수행하는 역할 중 분기와 점프의 경우 메모리 상의 특정 위치에 있는 명령 지정 필요
   but 컴파일 과정에서는 segment가 메모리 상의 어느 위치에 저장될 지 알 수 없음
   => logical adress 사용
        : logical adress는 실제 주소와 매핑되어 segment가 segment selector에 의해 자신의 시작 위치(offset)를 찾을 수 있게 함
       => 실제 메모리 주소(physical adress) = offset + logical adress

   # data segment(현재 모듈의 data segment, 상위 레벨로부터 받아들이는 데이터 모듈,  동적 생성 데이터,  공유 데이터)
     : 프로그램 실행시에 사용되는 데이터(전역변수)가 들어감

   # stack segment
     : 버퍼, 지역변수 등이 자리잡음
   + 버퍼
     하나의 장치에서 다른 장치로 데이터를 전송할 경우에 양자간의 데이터의 전송속도나 처리속도의 차를 보상하여 양호하게 결합할 목적으로 사용하는 기억영역을 버퍼 또는 버퍼 에어리어라고 한다.
     
    - 스택은 필요한 크기만큼 만들어짐

<8086 cpu 레지스터 구조>
 cpu가 프로세스 실행하려면 프로세스를 cpu에 적재시켜야 함 + 명령어 집합과 데이터들 적절히 집어내고 읽고 저장하기 위해 저장공간 필요 + 재빨리 읽고 쓰기 위해 cpu 내부의 메모리를 사용
 ==> 이러한 저장공간을 '레지스터'라고 함

  1) 범용 레지스터(General-Purpose register) : 논리 연산과 수리 연산에 사용되는 피연산자, 주소 계산에 사용되는 피연산자, 메모리 포인터 저장
     - 프로그래머가 임의로 조작 가능

EAX – 피연산자와 연산 결과의 저장소
EBX – DS segment안의 데이터를 가리키는 포인터
ECX – 문자열 처리나 루프를 위한 카운터
EDX – I/O 포인터
ESI – DS 레지스터가 가리키는 data segment 내의 어느 데이터를 가리키고 있는 포인터.
문자열 처리에서 source를 가리킴.
EDI – ES 레지스터가 가리키고 있는 data segment 내의 어느 데이터를 가리키고 있는 포
인터. 문자열 처리에서 destination을 가리킴.
ESP – SS 레지스터가 가리키는 stack segment의 맨 꼭대기를 가리키는 포인터
EBP – SS 레지스터가 가리키는 스텍상의 한 데이터를 가리키는 포인터

  2) 세그먼트 레지스터(segment resister) : code segment(CS 레지스터), data segment(DS, ES, FS, GS 레지스터), stack segment(SS 레지스터) 가리키는 주소가 들어가 있음

  3) 플래그 레지스터(Program status and control register) : 프로그램의 현재 상태나 조건 등을 검사하는 플래그들이 들어가 있음
     + 플래그? : 기(旗). 표지(標識). 표 . 프로그램 실행중에 특정 상태가 성립했는지의 여부를 식별하기 위하여 조사되는 데이터의 항목. 즉, 식별 또는 표시를 목적으로 하여 데이터에 붙여지는 표시기(indicator)이다.
    - 초기화되면 0x00000002의 값을 가짐
    - 1, 3, 5, 15, 22~31번 비트는 예약되어 있어 소프트웨어에 의해 조작할 수 없도록 되어있음
    - 컨트롤 플래그 레지스터 = 상태 플래그 + 컨트롤 플래그 + 시스템 플래그

status flags

 CF(carry flag) : 연산 수행 시 carry나 borrow (덧셈 연산시 bit bound를 넘어가거나 뺄샘을 하는데 빌려오는 경우) 가 발생하면 1이 됨 (부호없는 정수)
 OF(overflow flag) : 정수형 결과값이 너무 큰 양수이거나 너무 작은 음수여서 피연산자의 데이터 타입에 모두 들어가지 않을 경우 1이 됨 (부호있는 정수)
   ex) 부호없는 1byte 정수는 0~255의 범위를 가지는데 연산 결과가 0보다 작거나 255보다 크면 carry flag가 1이 됨
        부호가 없을 경우 -128~127의 범위를 가지고 이 범위를 벗어날 경우 overflow flag가 1이 됨
 PF(parity flag) : 연산 결과 최하위 바이트의 값이 짝수일 경우에 1이 됨. 패리티 체크에 사용됨
   + 이공학(理工學) 분야에서는 일반적으로 +와 -의 두 값을 취하는 양을 일컫는 용어.
      예컨대「0」과「1」의 조합으로 선호가 보내지는 디지틀 통신에서는 한 단락의 신호 중「1」의 수가 짝수인가 홀수인가에 따라서 패리티를 + 또는 -로 정의한다.
 AF(adjust flag) : 연산 결과 carry나 borrow가 3bit이상 발생하면 1이 됨
 ZF(zero flag) : 결과가 zero임을 가리킨다. 조건문이 만족되면 set됨
 SF(sign flag) : 연산결과 최상위 비트의 값과 같음. signed의 경우 양수이면 0, 음수이면 1
 DF(direction flag) : 문자열 처리에 있어서 1일 경우 문자열 처리 instruction이 자동으로 감
소(문자열 처리가 high address에서 low address로 이루어진다), 0일 경우 자동으로 증가 한
다.

system flags

IF(Interrupt enable flag) :프로세서에게 mask한 interrupt에 응답할 수 있게 하려면 1을 준다.
TF(Trap flag) : 디버깅을 할 때 single-step을 가능하게 하려면 1을 준다.
IOPL(I/O privilege level field) : 현재 수행 중인 프로세스 혹은 task의 권한 레벨을 가리킨다. 
                                        현재 수행 중인 프로세스의 권한을 가리키는 CPL이 I/O address 영역에 접근하기 위해서는 I/O privilege level보다 작거나 같아야 한다.
NT(Nested task flag) : Interrupt의 chain을 제어한다. 1이 되면 이전 실행 task와 현재 task가 연결되어 있음을 나타낸다.
RF(Resume flag) : Exception debug 하기 위해 프로세서의 응답을 제어한다.
VM(Virtual-8086 mode flag) :  Virtual-8086 모드를 사용하려면 1을 준다.
AC(Alignment check flag) : 이 비트와 CR0 레지스터의 AM 비트가 set되어 있으면 메모리 레퍼런스의 alignment checking이 가능하다.
VIF(Virtual interrupt flag) : IF flag의 가상 이미지이다. VIP flag와 결합시켜 사용한다.
VIP(Virtual interrupt pending flag) : 인터럽트가 pending(경쟁 상태) 되었음을 가리킨다.
ID(Identification flag) : CPUID instruction을 지원하는 CPU인지를 나타낸다.
 
  4) 인스트럭션 포인터(instruction pointer) : 다음 수행해야 하는 명령이 있는 메모리 상의 주소가 들어가 있음
     - 다음에 실행할 명령어가 있는 현재 code segment의 offset값을 가짐


< 프로그램 구동 시에 segment에서 일어나고 있는 일>

void function(int a, int b, int c){
char buffer1[15];
char buffer2[10];
}
void main(){
function(1, 2, 3);
}

---위의 프로그램을 실행시킬 때 code segment에 들어가는 내용---
0x804831f <main+35>: nop
0x804831e <main+34>: ret
0x804831d <main+33>: leave
0x804831a <main+30>: add $0x10,%esp
0x8048315 <main+25>: call 0x80482f4
0x8048313 <main+23>: push $0x1
0x8048311 <main+21>: push $0x2
0x804830f <main+19>: push $0x3
0x804830c <main+16>: sub $0x4,%esp
0x804830a <main+14>: sub %eax,%esp
0x8048305 <main+9>: mov $0x0,%eax
0x8048302 <main+6>: and $0xfffffff0,%esp
0x80482ff <main+3>: sub $0x8,%esp
0x80482fd <main+1>: mov %esp,%ebp
0x80482fc <main>: push %ebp             <-------------------------eip(extended instruction pointer)
0x80482fb <function+7>: ret
0x80482fa <function+6>: leave
0x80482f7 <function+3>: sub $0x28,%esp
0x80482f5 <function+1>: mov %esp,%ebp
0x80482f4 <function>: push %ebp

<step1>
eip는 메인 함수의 시작을 가리키고 있으며 esp는 push와 pop이 수행될 수 있도록 stack segment의 맨 꼭대기를 가리키고 있다.
이전 함수의 데이터를 보존하기 위해 ebp도 저장해야 한다. 함수가 시작될 때 stack pointer와 base pointer를 새로 지정하는 것이 함수의 프롤로그 과정이다.

<step2>
1) push %ebp
   이전 함수의 base pointer를 저장함. stack pointer는 4바이트 아래를 가리키게 됨
2) push %esp, %ebp
   esp 값을 ebp에 복사함. base pointer와 stack pointer가 같은 지점을 가리키게 됨
3) sub $0x8, %esp
   esp에서 8을 뺌 = esp가 8바이트 아래 지점을 가리키게 되고 스텍에 8바이트의 공간이 생김(스텍이 8바이트 확장됨)
4) and $fffffff0, %esp
   esp와 11111111 11111111 11111111 11110000 를 and연산시킨다. esp 주소값의 맨 뒤 4bit를 0으로 만들기 위함. 별 의미 없는 명령
5) mov $0x0, %eax
   eax레지스터에 0을 넣음
6) sub %eax %esp
   esp에서 eax에 들어있는 값만큼 뺌. eax에 0이 들어있으므로 의미없는 명령
7) sub $0x4 %esp
   스택을 4바이트 확장

--- 현재까지 esp는 12바이트 이동함 ---

<step3>
1) push $0x03
   push $0x02
   push $0x01
   function(1, 2, 3)을 수행하기 위해 1, 2, 3을 넣어준다. 후입선출의 구조이므로 3부터 넣어줌
2) call 0x80482f4
  0x80482f4에 있는 명령을 수행하라. 찾아보면 0x80482f4는 function 함수가 자리잡은 곳이다.
  call명령은 함수를 호출하는 명령으로 함수가 끝난 뒤 다음 명령을 계속 실행할 필요가 생김
  -->add $0x10, %esp 명령이 있는 주소를 스텍에 넣음
     ==>함수가 끝난 다음 어디에 있는 명령을 수행해야 할지 stack에서 pop할 수 있음. 이것을 'return address'라고 함
      그 후 eip가 함수의 시작 부분을 가리키도록 eip에 함수의 시작 지점 주소를 넣음

<step4>
1) push %ebp
   mov %esp, %ebp
   함수 프롤로그 실행. main()함수에서 사용하던 base pointer가 저장되고 stack pointer를 function()함수의 base pointer로 삼음

<step5>
1) sub $0x28 %esp
  스택을 40바이트 확장한다.
   --- 왜 40바이트? ---
   function()함수에서 지역변수로 buffer1[15]와 buffer2[10]을 선언했기 때문.
   각각 15바이트와 10바이트를 필요로 하지만 스텍은 word(4byte)단위로 자란다. 다만 gcc 2.96 이후의 버전에서는 9바이트 이상은 4word 단위로 할당된다. 또한 8바이트의 dummy가 들어간다.
   ==> buffer1[15]에 16바이트 + buffer2[10]에 16바이트 + dummy 8바이트 = 40바이트

<step6>
1) leave
   leave instruction 수행 = 함수 프롤로그 되돌리기
   push %ebp 
   mov %esp, %ebp
   을 되돌리기 위해 
   mov %ebp, %esp
   pop %ebp
   이 필요함. leave가 mov %ebp, %esp + pop %ebp의 역할 해냄
2) pop을 했으므로 stack pointer가 1word 위로 올라감 --> return address 가리킴
   ret instruction : 이전 함수로 return하라는 의미. eip레지스터에 return address를 pop하여 집어넣는 역할

<step7>
1) add $0x10 %esp
   스택을 16바이트 줄임
2) leave
   ret
   main()함수 프롤로그 작업을 되돌리고 main()함수 이전으로 돌아감
